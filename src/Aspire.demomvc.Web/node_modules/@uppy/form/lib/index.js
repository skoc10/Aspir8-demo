function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }
var id = 0;
function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }
import BasePlugin from '@uppy/core/lib/BasePlugin.js';
import findDOMElement from '@uppy/utils/lib/findDOMElement';
import toArray from '@uppy/utils/lib/toArray';

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore untyped
import getFormData from 'get-form-data';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore We don't want TS to generate types for the package.json
const packageJson = {
  "version": "3.2.1"
};
const defaultOptions = {
  resultName: 'uppyResult',
  getMetaFromForm: true,
  addResultToForm: true,
  submitOnSuccess: false,
  triggerUploadOnSubmit: false
};
function assertHTMLFormElement(input) {
  if (input == null || input.nodeName !== 'FORM') {
    throw new Error('ASSERTION FAILED: the target is not a <form> element', {
      cause: input
    });
  }
  return input;
}
var _completed = /*#__PURE__*/_classPrivateFieldLooseKey("completed");
export default class Form extends BasePlugin {
  constructor(uppy, opts) {
    super(uppy, {
      ...defaultOptions,
      ...opts
    });
    // TODO: make this private (or at least, mark it as readonly)
    /**
     * Unfortunately Uppy isn't a state machine in which we can guarantee it's
     * currently in one state and one state only so we use this completed property which is set on `upload-success'.
     */
    Object.defineProperty(this, _completed, {
      writable: true,
      value: false
    });
    this.type = 'acquirer';
    this.id = this.opts.id || 'Form';
    this.handleFormSubmit = this.handleFormSubmit.bind(this);
    this.handleUploadStart = this.handleUploadStart.bind(this);
    this.handleSuccess = this.handleSuccess.bind(this);
    this.addResultToForm = this.addResultToForm.bind(this);
    this.getMetaFromForm = this.getMetaFromForm.bind(this);
  }
  handleUploadStart() {
    _classPrivateFieldLooseBase(this, _completed)[_completed] = false;
    if (this.opts.getMetaFromForm) {
      this.getMetaFromForm();
    }
  }
  handleSuccess(result) {
    _classPrivateFieldLooseBase(this, _completed)[_completed] = true;
    if (this.opts.addResultToForm) {
      this.addResultToForm(result);
    }
    if (this.opts.submitOnSuccess) {
      this.form.requestSubmit();
    }
  }
  handleFormSubmit(ev) {
    if (this.opts.triggerUploadOnSubmit && !_classPrivateFieldLooseBase(this, _completed)[_completed]) {
      ev.preventDefault();
      const elements = toArray(ev.target.elements);
      const disabledByUppy = [];
      elements.forEach(el => {
        const isButton = el.tagName === 'BUTTON' || el.tagName === 'INPUT' && el.type === 'submit';
        if (isButton && !el.disabled) {
          ;
          el.disabled = true; // eslint-disable-line no-param-reassign
          disabledByUppy.push(el);
        }
      });
      this.uppy.upload().then(() => {
        disabledByUppy.forEach(button => {
          button.disabled = false; // eslint-disable-line no-param-reassign
        });
      }, err => {
        disabledByUppy.forEach(button => {
          button.disabled = false; // eslint-disable-line no-param-reassign
        });
        return Promise.reject(err);
      }).catch(err => {
        this.uppy.log(err.stack || err.message || err);
      });
    }
  }
  addResultToForm(result) {
    this.uppy.log('[Form] Adding result to the original form:');
    this.uppy.log(result);
    let resultInput = this.form.querySelector(`[name="${this.opts.resultName}"]`);
    if (resultInput) {
      // Append new result to the previous result array.
      // If the previous result is empty, or not an array,
      // set it to an empty array.
      let updatedResult;
      try {
        updatedResult = JSON.parse(resultInput.value);
      } catch (err) {
        // Nothing, since we check for array below anyway
      }
      if (!Array.isArray(updatedResult)) {
        updatedResult = [];
      }
      updatedResult.push(result);
      resultInput.value = JSON.stringify(updatedResult);
      return;
    }
    resultInput = document.createElement('input');
    resultInput.name = this.opts.resultName;
    resultInput.type = 'hidden';
    resultInput.value = JSON.stringify([result]);
    this.form.appendChild(resultInput);
  }
  getMetaFromForm() {
    const formMeta = getFormData(this.form);
    // We want to exclude meta the the Form plugin itself has added
    // See https://github.com/transloadit/uppy/issues/1637
    delete formMeta[this.opts.resultName];
    this.uppy.setMeta(formMeta);
  }
  install() {
    this.form = assertHTMLFormElement(findDOMElement(this.opts.target));
    this.form.addEventListener('submit', this.handleFormSubmit);
    this.uppy.on('upload', this.handleUploadStart);
    this.uppy.on('complete', this.handleSuccess);
  }
  uninstall() {
    this.form.removeEventListener('submit', this.handleFormSubmit);
    this.uppy.off('upload', this.handleUploadStart);
    this.uppy.off('complete', this.handleSuccess);
  }
}
Form.VERSION = packageJson.version;